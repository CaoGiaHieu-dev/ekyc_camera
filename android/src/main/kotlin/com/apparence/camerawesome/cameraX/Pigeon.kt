// Autogenerated from Pigeon (v4.2.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

package com.apparence.camerawesome.cameraX

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

/** Generated class from Pigeon. */

enum class PigeonSensorType(val raw: Int) {
    WIDEANGLE(0),
    ULTRAWIDEANGLE(1),
    TELEPHOTO(2),
    TRUEDEPTH(3),
    UNKNOWN(4);

    companion object {
        fun ofRaw(raw: Int): PigeonSensorType? {
            return values().firstOrNull { it.raw == raw }
        }
    }
}

enum class CamerAwesomePermission(val raw: Int) {
    STORAGE(0),
    CAMERA(1),
    LOCATION(2),
    RECORD_AUDIO(3);

    companion object {
        fun ofRaw(raw: Int): CamerAwesomePermission? {
            return values().firstOrNull { it.raw == raw }
        }
    }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PreviewSize(
    val width: Double,
    val height: Double
) {
    companion object {
        @Suppress("UNCHECKED_CAST")
        fun fromMap(map: Map<String, Any?>): PreviewSize {
            val width = map["width"] as Double
            val height = map["height"] as Double

            return PreviewSize(width, height)
        }
    }

    fun toMap(): Map<String, Any?> {
        val map = mutableMapOf<String, Any?>()
        map["width"] = width
        map["height"] = height
        return map
    }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ExifPreferences(
    val saveGPSLocation: Boolean
) {
    companion object {
        @Suppress("UNCHECKED_CAST")
        fun fromMap(map: Map<String, Any?>): ExifPreferences {
            val saveGPSLocation = map["saveGPSLocation"] as Boolean

            return ExifPreferences(saveGPSLocation)
        }
    }

    fun toMap(): Map<String, Any?> {
        val map = mutableMapOf<String, Any?>()
        map["saveGPSLocation"] = saveGPSLocation
        return map
    }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class VideoOptions(
    val fileType: String,
    val codec: String
) {
    companion object {
        @Suppress("UNCHECKED_CAST")
        fun fromMap(map: Map<String, Any?>): VideoOptions {
            val fileType = map["fileType"] as String
            val codec = map["codec"] as String

            return VideoOptions(fileType, codec)
        }
    }

    fun toMap(): Map<String, Any?> {
        val map = mutableMapOf<String, Any?>()
        map["fileType"] = fileType
        map["codec"] = codec
        return map
    }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PigeonSensorTypeDevice(
    val sensorType: PigeonSensorType,
    val name: String,
    val iso: Double,
    val flashAvailable: Boolean,
    val uid: String
) {
    companion object {
        @Suppress("UNCHECKED_CAST")
        fun fromMap(map: Map<String, Any?>): PigeonSensorTypeDevice {
            val sensorType = PigeonSensorType.ofRaw(map["sensorType"] as Int)!!
            val name = map["name"] as String
            val iso = map["iso"] as Double
            val flashAvailable = map["flashAvailable"] as Boolean
            val uid = map["uid"] as String

            return PigeonSensorTypeDevice(sensorType, name, iso, flashAvailable, uid)
        }
    }

    fun toMap(): Map<String, Any?> {
        val map = mutableMapOf<String, Any?>()
        map["sensorType"] = sensorType.raw
        map["name"] = name
        map["iso"] = iso
        map["flashAvailable"] = flashAvailable
        map["uid"] = uid
        return map
    }
}

@Suppress("UNCHECKED_CAST")
private object CameraInterfaceCodec : StandardMessageCodec() {
    override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
        return when (type) {
            128.toByte() -> {
                return (readValue(buffer) as? Map<String, Any?>)?.let {
                    ExifPreferences.fromMap(it)
                }
            }
            129.toByte() -> {
                return (readValue(buffer) as? Map<String, Any?>)?.let {
                    PigeonSensorTypeDevice.fromMap(it)
                }
            }
            130.toByte() -> {
                return (readValue(buffer) as? Map<String, Any?>)?.let {
                    PreviewSize.fromMap(it)
                }
            }
            131.toByte() -> {
                return (readValue(buffer) as? Map<String, Any?>)?.let {
                    PreviewSize.fromMap(it)
                }
            }
            132.toByte() -> {
                return (readValue(buffer) as? Map<String, Any?>)?.let {
                    VideoOptions.fromMap(it)
                }
            }
            else -> super.readValueOfType(type, buffer)
        }
    }

    override fun writeValue(stream: ByteArrayOutputStream, value: Any?) {
        when (value) {
            is ExifPreferences -> {
                stream.write(128)
                writeValue(stream, value.toMap())
            }
            is PigeonSensorTypeDevice -> {
                stream.write(129)
                writeValue(stream, value.toMap())
            }
            is PreviewSize -> {
                stream.write(130)
                writeValue(stream, value.toMap())
            }
            is PreviewSize -> {
                stream.write(131)
                writeValue(stream, value.toMap())
            }
            is VideoOptions -> {
                stream.write(132)
                writeValue(stream, value.toMap())
            }
            else -> super.writeValue(stream, value)
        }
    }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface CameraInterface {
    fun setupCamera(
        sensor: String,
        aspectRatio: String,
        zoom: Double,
        flashMode: String,
        captureMode: String,
        enableImageStream: Boolean,
        exifPreferences: ExifPreferences,
        callback: (Boolean) -> Unit
    )

    fun checkPermissions(): List<String>
    fun requestPermissions(saveGpsLocation: Boolean, callback: (List<String>) -> Unit)
    fun getPreviewTextureId(): Long
    fun takePhoto(callback: (ByteArray?) -> Unit)
    fun recordVideo(path: String, options: VideoOptions?, callback: () -> Unit)
    fun pauseVideoRecording()
    fun resumeVideoRecording()
    fun receivedImageFromStream()
    fun stopRecordingVideo(callback: (Boolean) -> Unit)
    fun getFrontSensors(): List<PigeonSensorTypeDevice>
    fun getBackSensors(): List<PigeonSensorTypeDevice>
    fun start(): Boolean
    fun stop(): Boolean
    fun setFlashMode(mode: String)
    fun handleAutoFocus()
    fun focusOnPoint(previewSize: PreviewSize, x: Double, y: Double)
    fun setZoom(zoom: Double)
    fun setSensor(sensor: String, deviceId: String?)
    fun setCorrection(brightness: Double)
    fun getMaxZoom(): Double
    fun setCaptureMode(mode: String)
    fun setRecordingAudioMode(enableAudio: Boolean, callback: (Boolean) -> Unit)
    fun availableSizes(): List<PreviewSize>
    fun refresh()
    fun getEffectivPreviewSize(): PreviewSize?
    fun setPhotoSize(size: PreviewSize)
    fun setPreviewSize(size: PreviewSize)
    fun setAspectRatio(aspectRatio: String)
    fun setupImageAnalysisStream(
        format: String,
        width: Long,
        maxFramesPerSecond: Double?,
        autoStart: Boolean
    )

    fun setExifPreferences(exifPreferences: ExifPreferences, callback: (Boolean) -> Unit)
    fun startAnalysis()
    fun stopAnalysis()
    fun setFilter(matrix: List<Double>)

    companion object {
        /** The codec used by CameraInterface. */
        val codec: MessageCodec<Any?> by lazy {
            CameraInterfaceCodec
        }

        /** Sets up an instance of `CameraInterface` to handle messages through the `binaryMessenger`. */
        @Suppress("UNCHECKED_CAST")
        fun setUp(binaryMessenger: BinaryMessenger, api: CameraInterface?) {
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setupCamera",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val sensorArg = args[0] as String
                            val aspectRatioArg = args[1] as String
                            val zoomArg = args[2] as Double
                            val flashModeArg = args[3] as String
                            val captureModeArg = args[4] as String
                            val enableImageStreamArg = args[5] as Boolean
                            val exifPreferencesArg = args[6] as ExifPreferences
                            api.setupCamera(
                                sensorArg,
                                aspectRatioArg,
                                zoomArg,
                                flashModeArg,
                                captureModeArg,
                                enableImageStreamArg,
                                exifPreferencesArg
                            ) {
                                reply.reply(wrapResult(it))
                            }
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                            reply.reply(wrapped)
                        }
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.checkPermissions",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            wrapped["result"] = api.checkPermissions()
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.requestPermissions",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val saveGpsLocationArg = args[0] as Boolean
                            api.requestPermissions(saveGpsLocationArg) {
                                reply.reply(wrapResult(it))
                            }
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                            reply.reply(wrapped)
                        }
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.getPreviewTextureId",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            wrapped["result"] = api.getPreviewTextureId()
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.takePhoto",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            api.takePhoto() {
                                reply.reply(wrapResult(it))
                            }
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                            reply.reply(wrapped)
                        }
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.recordVideo",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val pathArg = args[0] as String
                            val optionsArg = args[1] as? VideoOptions
                            api.recordVideo(pathArg, optionsArg) {
                                reply.reply(null)
                            }
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                            reply.reply(wrapped)
                        }
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.pauseVideoRecording",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            api.pauseVideoRecording()
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.resumeVideoRecording",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            api.resumeVideoRecording()
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.receivedImageFromStream",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            api.receivedImageFromStream()
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.stopRecordingVideo",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            api.stopRecordingVideo() {
                                reply.reply(wrapResult(it))
                            }
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                            reply.reply(wrapped)
                        }
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.getFrontSensors",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            wrapped["result"] = api.getFrontSensors()
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.getBackSensors",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            wrapped["result"] = api.getBackSensors()
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.start",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            wrapped["result"] = api.start()
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.stop",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            wrapped["result"] = api.stop()
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setFlashMode",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val modeArg = args[0] as String
                            api.setFlashMode(modeArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.handleAutoFocus",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            api.handleAutoFocus()
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.focusOnPoint",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val previewSizeArg = args[0] as PreviewSize
                            val xArg = args[1] as Double
                            val yArg = args[2] as Double
                            api.focusOnPoint(previewSizeArg, xArg, yArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setZoom",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val zoomArg = args[0] as Double
                            api.setZoom(zoomArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setSensor",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val sensorArg = args[0] as String
                            val deviceIdArg = args[1] as? String
                            api.setSensor(sensorArg, deviceIdArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setCorrection",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val brightnessArg = args[0] as Double
                            api.setCorrection(brightnessArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.getMaxZoom",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            wrapped["result"] = api.getMaxZoom()
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setCaptureMode",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val modeArg = args[0] as String
                            api.setCaptureMode(modeArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setRecordingAudioMode",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val enableAudioArg = args[0] as Boolean
                            api.setRecordingAudioMode(enableAudioArg) {
                                reply.reply(wrapResult(it))
                            }
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                            reply.reply(wrapped)
                        }
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.availableSizes",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            wrapped["result"] = api.availableSizes()
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.refresh",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            api.refresh()
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.getEffectivPreviewSize",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            wrapped["result"] = api.getEffectivPreviewSize()
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setPhotoSize",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val sizeArg = args[0] as PreviewSize
                            api.setPhotoSize(sizeArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setPreviewSize",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val sizeArg = args[0] as PreviewSize
                            api.setPreviewSize(sizeArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setAspectRatio",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val aspectRatioArg = args[0] as String
                            api.setAspectRatio(aspectRatioArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setupImageAnalysisStream",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val formatArg = args[0] as String
                            val widthArg =
                                args[1].let { if (it is Int) it.toLong() else it as Long }
                            val maxFramesPerSecondArg = args[2] as? Double
                            val autoStartArg = args[3] as Boolean
                            api.setupImageAnalysisStream(
                                formatArg,
                                widthArg,
                                maxFramesPerSecondArg,
                                autoStartArg
                            )
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setExifPreferences",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val exifPreferencesArg = args[0] as ExifPreferences
                            api.setExifPreferences(exifPreferencesArg) {
                                reply.reply(wrapResult(it))
                            }
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                            reply.reply(wrapped)
                        }
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.startAnalysis",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            api.startAnalysis()
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.stopAnalysis",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { _, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            api.stopAnalysis()
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
            run {
                val channel = BasicMessageChannel<Any?>(
                    binaryMessenger,
                    "dev.flutter.pigeon.CameraInterface.setFilter",
                    codec
                )
                if (api != null) {
                    channel.setMessageHandler { message, reply ->
                        val wrapped = hashMapOf<String, Any?>()
                        try {
                            val args = message as List<Any?>
                            val matrixArg = args[0] as List<Double>
                            api.setFilter(matrixArg)
                            wrapped["result"] = null
                        } catch (exception: Error) {
                            wrapped["error"] = wrapError(exception)
                        }
                        reply.reply(wrapped)
                    }
                } else {
                    channel.setMessageHandler(null)
                }
            }
        }
    }
}

private fun wrapResult(result: Any?): Map<String, Any?> {
    return hashMapOf("result" to result)
}

private fun wrapError(exception: Throwable): Map<String, Any> {
    return hashMapOf<String, Any>(
        "error" to hashMapOf<String, Any>(
            "code" to exception.javaClass.simpleName,
            "message" to exception.toString(),
            "details" to "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(
                exception
            )
        )
    )
}
